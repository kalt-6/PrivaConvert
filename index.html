<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PrivaConvert | The Ultimate Local Converter Suite</title>
    
    <!-- Primary SEO -->
    <meta name="description" id="meta-desc" content="A completely private, local file conversion suite. Convert images, audio, video, and documents securely in your browser with zero server uploads using WebAssembly technology.">
    <meta name="keywords" content="file converter, local converter, privacy, image converter, video converter, audio converter, pdf converter, no upload converter">
    
    <!-- CRITICAL FIX: Dynamic Canonical Tag -->
    <link rel="canonical" id="canonical-url" href="">

    <!-- Open Graph / Social Media SEO -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="PrivaConvert | Local & Private File Conversion">
    <meta property="og:description" content="Convert your files safely in your browser. No uploads, no servers, 100% private.">
    <meta property="og:image" content="logo.png">
    
    <!-- FAVICON FIX FOR GOOGLE SEARCH -->
    <!-- Google requires icons to be square and at least 48x48px (preferably 96x96px or higher) -->
    <link rel="icon" type="image/png" href="logo.png" sizes="48x48">
    <link rel="icon" type="image/png" href="logo.png" sizes="96x96">
    <link rel="apple-touch-icon" href="logo.png">
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <!-- Libraries for Conversion -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "SoftwareApplication",
      "name": "PrivaConvert",
      "operatingSystem": "Web Browser",
      "applicationCategory": "MultimediaApplication",
      "offers": { "price": "0", "priceCurrency": "USD" },
      "description": "Convert images, audio, video, and documents locally in your browser with zero server uploads."
    }
    </script>
    
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        slate: { 850: '#151e2e', 900: '#0f172a', 950: '#020617' },
                        emerald: { 450: '#10b981' }
                    },
                    animation: { 'pulse-slow': 'pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite' }
                }
            }
        }
    </script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; background-color: #020617; color: #e2e8f0; scroll-behavior: smooth; }
        .glass-panel { background: rgba(30, 41, 59, 0.7); backdrop-filter: blur(12px); border: 1px solid rgba(255, 255, 255, 0.08); }
        .drop-zone { transition: all 0.3s ease; border: 2px dashed #334155; background-color: rgba(15, 23, 42, 0.3); }
        .drop-zone.active { background-color: rgba(16, 185, 129, 0.1); border-color: #10b981; transform: scale(1.01); }
        .custom-scroll::-webkit-scrollbar { width: 6px; }
        .custom-scroll::-webkit-scrollbar-track { background: #1e293b; }
        .custom-scroll::-webkit-scrollbar-thumb { background: #475569; border-radius: 3px; }
        #hidden-render { position: absolute; top: -9999px; left: -9999px; width: 794px; padding: 40px; }
        #app-message { transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1); transform: translate(-50%, 20px); opacity: 0; visibility: hidden; pointer-events: none; }
        #app-message.show { transform: translate(-50%, 0); opacity: 1; visibility: visible; }
        
        /* Link styling for SEO links */
        .seo-link {
            display: block;
            background-color: rgba(15, 23, 42, 0.5);
            border: 1px solid #1e293b;
            padding: 0.75rem;
            border-radius: 0.75rem;
            text-align: center;
            font-size: 10px;
            font-weight: 600;
            color: #94a3b8;
            transition: all 0.2s;
            text-decoration: none;
            text-transform: uppercase;
        }
        .seo-link:hover {
            border-color: rgba(16, 185, 129, 0.4);
            color: #34d399;
        }
    </style>
</head>
<body class="min-h-screen flex flex-col selection:bg-emerald-500 selection:text-white">

    <!-- Notification UI -->
    <div id="app-message" class="fixed bottom-10 left-1/2 z-[200]">
        <div class="glass-panel bg-slate-900 border border-emerald-500/30 text-white px-6 py-3 rounded-2xl shadow-2xl flex items-center gap-3">
            <div class="bg-emerald-500/20 p-1.5 rounded-full"><i data-lucide="info" id="message-icon" class="h-4 w-4 text-emerald-400"></i></div>
            <span id="message-text" class="text-sm font-semibold tracking-wide"></span>
        </div>
    </div>

    <!-- Navigation -->
    <nav class="border-b border-slate-800 bg-slate-950/80 backdrop-blur-md sticky top-0 z-50">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex items-center justify-between h-16">
                <a href="/" class="flex items-center gap-2 group">
                    <div class="bg-emerald-500/10 p-2 rounded-lg border border-emerald-500/20 group-hover:border-emerald-500/50 transition-colors">
                        <i data-lucide="shield-check" class="h-6 w-6 text-emerald-500"></i>
                    </div>
                    <span class="font-bold text-xl tracking-tight text-white">Priva<span class="text-emerald-500">Convert</span></span>
                </a>
                <div class="hidden md:flex items-center gap-4">
                    <div class="flex items-center gap-2 px-3 py-1.5 rounded-full bg-slate-900 border border-slate-800 text-[10px] uppercase tracking-wider text-slate-400 font-bold">
                        <span class="w-1.5 h-1.5 rounded-full bg-emerald-500 animate-pulse"></span>
                        Secure local environment
                    </div>
                </div>
            </div>
        </div>
    </nav>

    <main class="flex-grow flex flex-col items-center justify-center p-4 sm:p-8 relative overflow-hidden">
        
        <div class="absolute top-0 left-0 w-full h-full overflow-hidden -z-10 pointer-events-none">
            <div class="absolute top-[-10%] left-[-10%] w-[40%] h-[40%] bg-emerald-500/5 rounded-full blur-[120px]"></div>
            <div class="absolute bottom-[-10%] right-[-10%] w-[40%] h-[40%] bg-blue-600/5 rounded-full blur-[120px]"></div>
        </div>

        <div class="text-center mb-10 max-w-3xl mx-auto space-y-4">
            <h1 class="text-4xl sm:text-5xl font-bold text-white tracking-tight leading-tight" id="hero-main-heading">Universal Local Converter</h1>
            <h2 class="text-2xl font-semibold"><span class="text-transparent bg-clip-text bg-gradient-to-r from-emerald-400 to-emerald-600" id="hero-title">Completely Private.</span></h2>
            <p class="text-slate-400 text-lg leading-relaxed max-w-2xl mx-auto">PrivaConvert is a completely private, local file conversion suite. Files are processed directly on your device with zero server uploads.</p>
            <p class="text-slate-500 text-sm font-medium" id="univ-subtitle">Convert images, audio, video, and documents securely in your browser.</p>
        </div>

        <div class="w-full max-w-4xl glass-panel rounded-2xl shadow-2xl relative" id="app-container">
            <div id="tool-universal" class="tool-view">
                <div class="bg-slate-900/50 p-6 border-b border-white/5 flex flex-col items-center justify-center gap-6 relative z-50 overflow-visible">
                    <div class="flex flex-col sm:flex-row items-center gap-3 w-full justify-center">
                        <!-- FROM -->
                        <div class="relative w-full sm:w-48 z-50">
                            <label class="text-[10px] uppercase text-slate-500 font-bold mb-1 ml-1 block">Convert</label>
                            <button id="from-selector-btn" class="w-full bg-slate-800 border border-slate-700 hover:border-emerald-500/50 text-white text-sm rounded-lg p-3 flex items-center justify-between transition-all group">
                                <span class="flex items-center gap-2"><span class="bg-slate-700 p-1 rounded text-emerald-400 text-xs font-bold w-12 text-center" id="from-format-badge">...</span><span id="from-format-label" class="truncate">Select</span></span>
                                <i data-lucide="chevron-down" class="h-4 w-4 text-slate-400 group-hover:text-emerald-500 transition-colors"></i>
                            </button>
                            <div id="from-selector-menu" class="hidden absolute top-full left-0 mt-2 w-[320px] bg-slate-900 border border-slate-700 rounded-xl shadow-2xl overflow-hidden z-[100]"></div>
                        </div>

                        <!-- Swap -->
                        <button id="swap-btn" class="p-2.5 rounded-full bg-slate-800 hover:bg-slate-700 border border-slate-700 hover:border-emerald-500/50 text-slate-400 hover:text-emerald-400 transition-all shadow-lg active:scale-90 group mt-4 sm:mt-4">
                            <i data-lucide="arrow-right-left" class="h-4 w-4 group-hover:rotate-180 transition-transform duration-500"></i>
                        </button>

                        <!-- TO -->
                        <div class="relative w-full sm:w-48 z-40">
                            <label class="text-[10px] uppercase text-slate-500 font-bold mb-1 ml-1 block">Into</label>
                            <button id="to-selector-btn" class="w-full bg-slate-800 border border-slate-700 hover:border-emerald-500/50 text-white text-sm rounded-lg p-3 flex items-center justify-between transition-all group">
                                <span class="flex items-center gap-2"><span class="bg-slate-700 p-1 rounded text-emerald-400 text-xs font-bold w-12 text-center" id="to-format-badge">...</span><span id="to-format-label" class="truncate">Select</span></span>
                                <i data-lucide="chevron-down" class="h-4 w-4 text-slate-400 group-hover:text-emerald-500 transition-colors"></i>
                            </button>
                            <div id="to-selector-menu" class="hidden absolute top-full right-0 mt-2 w-[320px] bg-slate-900 border border-slate-700 rounded-xl shadow-2xl overflow-hidden z-[100]"></div>
                        </div>
                    </div>
                </div>

                <div class="p-8 relative z-10">
                    <div id="drop-zone-univ" class="drop-zone relative rounded-2xl h-64 flex flex-col items-center justify-center cursor-pointer group">
                        <input type="file" id="file-input-univ" class="absolute inset-0 w-full h-full opacity-0 cursor-pointer z-10" multiple>
                        <div class="z-0 flex flex-col items-center space-y-4 pointer-events-none transition-transform group-hover:scale-105">
                            <div class="p-4 bg-slate-800 rounded-full border border-slate-700 shadow-xl group-hover:border-emerald-500/50 transition-colors"><i data-lucide="upload-cloud" class="h-10 w-10 text-emerald-500"></i></div>
                            <div class="text-center"><p class="text-lg font-medium text-white group-hover:text-emerald-400 transition-colors">Click or drag files here</p><p class="text-sm text-slate-500 mt-1" id="drop-subtitle">Select formats or drop a file to begin</p></div>
                        </div>
                    </div>

                    <div id="ffmpeg-loader" class="hidden mt-4 bg-slate-800/50 p-3 rounded-lg border border-slate-700 relative">
                        <button id="cancel-btn" class="absolute -top-2 -right-2 bg-slate-700 hover:bg-red-500 text-white rounded-full p-1.5 border border-slate-600 shadow-md transition-colors z-10" title="Cancel All"><i data-lucide="x" class="h-3 w-3"></i></button>
                        <div class="flex items-center justify-between text-xs text-slate-400 mb-2"><span id="ffmpeg-label">Initializing Media Engine...</span><span id="ffmpeg-status">0%</span></div>
                        <div class="w-full bg-slate-700 rounded-full h-1.5 overflow-hidden"><div class="bg-emerald-500 h-1.5 rounded-full transition-all duration-300" style="width: 0%" id="ffmpeg-progress"></div></div>
                    </div>

                    <div id="results-area-univ" class="hidden mt-8 space-y-4">
                        <div class="flex items-center justify-between border-b border-slate-800 pb-2"><h3 class="text-sm font-semibold text-slate-400 uppercase tracking-wider">Queue</h3><button onclick="clearAll()" class="text-xs text-red-400 hover:text-red-300 transition-colors">Clear All</button></div>
                        <div id="file-list-univ" class="space-y-3 max-h-60 overflow-y-auto pr-2 custom-scroll"></div>
                        <div class="flex justify-end pt-4"><button id="download-all-univ" class="hidden bg-emerald-600 hover:bg-emerald-500 text-white px-6 py-2 rounded-lg text-sm font-semibold shadow-lg shadow-emerald-500/20 transition-all flex items-center gap-2 active:scale-95"><i data-lucide="download"></i> Download All (.zip)</button></div>
                    </div>
                </div>
            </div>
            <div class="bg-slate-900 border-t border-slate-800 p-3 flex items-center justify-center gap-2 text-[10px] text-slate-500 uppercase tracking-widest font-bold"><i data-lucide="lock" class="h-3 w-3"></i><span>NO DATA LEAVES YOUR DEVICE</span></div>
        </div>

        <section class="w-full max-w-5xl mt-16 px-4">
            <h3 class="text-sm font-bold text-slate-500 uppercase tracking-widest mb-6 text-center">Popular Conversion Tools</h3>
            <!-- Static SEO Links (Hardcoded for Crawler Discovery) -->
            <div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-6 gap-3" id="seo-links-container">
                <a href="?from=png&to=ico" class="seo-link">PNG to ICO</a>
                <a href="?from=jpg&to=png" class="seo-link">JPG to PNG</a>
                <a href="?from=mp4&to=mp3" class="seo-link">MP4 to MP3</a>
                <a href="?from=pdf&to=jpg" class="seo-link">PDF to JPG</a>
                <a href="?from=webp&to=png" class="seo-link">WEBP to PNG</a>
                <a href="?from=mov&to=mp4" class="seo-link">MOV to MP4</a>
                <a href="?from=wav&to=mp3" class="seo-link">WAV to MP3</a>
                <a href="?from=flac&to=wav" class="seo-link">FLAC to WAV</a>
                <a href="?from=mp4&to=webm" class="seo-link">MP4 to WEBM</a>
                <a href="?from=png&to=pdf" class="seo-link">PNG to PDF</a>
                <a href="?from=md&to=pdf" class="seo-link">MD to PDF</a>
                <a href="?from=gif&to=mp4" class="seo-link">GIF to MP4</a>
                <a href="?from=pdf&to=png" class="seo-link">PDF to PNG</a>
                <a href="?from=bmp&to=jpg" class="seo-link">BMP to JPG</a>
                <a href="?from=tiff&to=png" class="seo-link">TIFF to PNG</a>
                <a href="?from=mkv&to=mp4" class="seo-link">MKV to MP4</a>
                <a href="?from=avi&to=mp4" class="seo-link">AVI to MP4</a>
                <a href="?from=webm&to=mp4" class="seo-link">WEBM to MP4</a>
            </div>
        </section>
    </main>

    <footer class="bg-slate-950 border-t border-slate-800 py-12 mt-20">
        <div class="max-w-7xl mx-auto px-4 text-center"><p class="text-slate-500 text-sm">PrivaConvert &copy; 2025 â€” Local Browser Utility</p></div>
    </footer>

    <div id="hidden-render"></div>

    <script>
        // --- Data Definitions ---
        const inputCategories = [
            { title: "Audio", formats: [{ val: "aac", label: "AAC", accept: ".aac,audio/aac", type: "audio" }, { val: "aiff", label: "AIFF", accept: ".aiff,.aif,audio/aiff", type: "audio" }, { val: "flac", label: "FLAC", accept: ".flac,audio/flac", type: "audio" }, { val: "m4a", label: "M4A", accept: ".m4a,audio/mp4", type: "audio" }, { val: "mp3", label: "MP3", accept: ".mp3,audio/mpeg", type: "audio" }, { val: "ogg", label: "OGG", accept: ".ogg,audio/ogg", type: "audio" }, { val: "wav", label: "WAV", accept: ".wav,audio/wav", type: "audio" }, { val: "wma", label: "WMA", accept: ".wma,audio/x-ms-wma", type: "audio" }] },
            { title: "Document", formats: [{ val: "md", label: "MD", accept: ".md,text/markdown,text/plain", type: "text" }, { val: "pdf", label: "PDF", accept: ".pdf,application/pdf", type: "doc" }, { val: "txt", label: "TXT", accept: ".txt,text/plain", type: "text" }] },
            { title: "Image", formats: [{ val: "bmp", label: "BMP", accept: ".bmp,image/bmp", type: "image" }, { val: "gif", label: "GIF", accept: ".gif,image/gif", type: "image" }, { val: "ico", label: "ICO", accept: ".ico,image/x-icon", type: "image" }, { val: "jpg", label: "JPG", accept: ".jpg,.jpeg,image/jpeg", type: "image" }, { val: "png", label: "PNG", accept: ".png,image/png", type: "image" }, { val: "tiff", label: "TIFF", accept: ".tiff,.tif,image/tiff", type: "image" }, { val: "webp", label: "WEBP", accept: ".webp,image/webp", type: "image" }] },
            { title: "Video", formats: [{ val: "avi", label: "AVI", accept: ".avi,video/x-msvideo", type: "video" }, { val: "mkv", label: "MKV", accept: ".mkv,video/x-matroska", type: "video" }, { val: "mov", label: "MOV", accept: ".mov,video/quicktime", type: "video" }, { val: "mp4", label: "MP4", accept: ".mp4,video/mp4", type: "video" }, { val: "webm", label: "WEBM", accept: ".webm,video/webm", type: "video" }, { val: "wmv", label: "WMV", accept: ".wmv,video/x-ms-wmv", type: "video" }] }
        ];

        const outputMaps = {
            'image': [{ val: "bmp", label: "BMP", category: "Image" }, { val: "gif", label: "GIF", category: "Image" }, { val: "ico", label: "ICO", category: "Image" }, { val: "jpg", label: "JPG", category: "Image" }, { val: "pdf", label: "PDF", category: "Document" }, { val: "png", label: "PNG", category: "Image" }, { val: "tiff", label: "TIFF", category: "Image" }, { val: "webp", label: "WEBP", category: "Image" }],
            'audio': [
                { val: "aac", label: "AAC", category: "Audio" }, 
                { val: "aiff", label: "AIFF", category: "Audio" }, 
                { val: "flac", label: "FLAC", category: "Audio" }, 
                { val: "m4a", label: "M4A", category: "Audio" }, 
                { val: "mp3", label: "MP3", category: "Audio" }, 
                { val: "ogg", label: "OGG", category: "Audio" }, 
                { val: "wav", label: "WAV", category: "Audio" }, 
                { val: "wma", label: "WMA", category: "Audio" },
                // Expanded functionality: Audio to Video Containers (muxing)
                { val: "mp4", label: "MP4", category: "Video" },
                { val: "mkv", label: "MKV", category: "Video" },
                { val: "mov", label: "MOV", category: "Video" },
                { val: "webm", label: "WEBM", category: "Video" }
            ],
            'video': [{ val: "avi", label: "AVI", category: "Video" }, { val: "gif", label: "GIF", category: "Image" }, { val: "flac", label: "FLAC", category: "Audio" }, { val: "mkv", label: "MKV", category: "Video" }, { val: "mov", label: "MOV", category: "Video" }, { val: "mp3", label: "MP3", category: "Audio" }, { val: "mp4", label: "MP4", category: "Video" }, { val: "webm", label: "WEBM", category: "Video" }, { val: "wma", label: "WMA", category: "Audio" }, { val: "wmv", label: "WMV", category: "Video" }],
            'doc': [{ val: "jpg", label: "JPG", category: "Image" }, { val: "png", label: "PNG", category: "Image" }, { val: "webp", label: "WEBP", category: "Image" }, { val: "txt", label: "TXT", category: "Document" }, { val: "md", label: "MD", category: "Document" }, { val: "html", label: "HTML", category: "Web" }],
            'text': [{ val: "html", label: "HTML", category: "Web" }, { val: "pdf", label: "PDF", category: "Document" }]
        };

        // --- Global State ---
        let selectedFrom = null, selectedTo = null, processedFiles = [], conversionQueue = [], isProcessing = false, pendingFiles = [], currentWorker = null, cancelCurrentTask = null, ffmpegLibUrl = null;

        // UI Refs
        let dropZoneUniv, fileInputUniv, resultsAreaUniv, fileListUniv, downloadAllUniv, ffmpegLoader, ffmpegProgress, ffmpegStatus, ffmpegLabel, fromBtn, fromMenu, fromBadge, fromLabel, toBtn, toMenu, toBadge, toLabel, swapBtn, cancelBtn;

        // --- UI Utilities ---
        function showMessage(text, isError = false) {
            const msgEl = document.getElementById('app-message');
            const msgText = document.getElementById('message-text');
            const msgIcon = document.getElementById('message-icon');
            if (msgText) msgText.textContent = text;
            if (msgIcon) msgIcon.className = isError ? "h-4 w-4 text-red-400" : "h-4 w-4 text-emerald-400";
            if (msgEl) {
                msgEl.classList.add('show');
                setTimeout(() => { if (msgEl) msgEl.classList.remove('show'); }, 3000);
            }
        }

        // --- Core Functions ---
        function renderSplitMenu(containerId, categoriesData, onSelectCallback) {
            const container = document.getElementById(containerId); 
            if(!container) return;
            container.innerHTML = '';
            container.classList.add('flex', 'flex-row', 'h-[320px]');
            
            const sideBar = document.createElement('div'); 
            sideBar.className = "w-2/5 bg-slate-900 border-r border-slate-700 overflow-y-auto py-2 custom-scroll"; 
            const contentArea = document.createElement('div'); 
            contentArea.className = "w-3/5 overflow-y-auto custom-scroll bg-slate-900/40";
            
            const renderRightSide = (formats) => {
                contentArea.innerHTML = '';
                formats.forEach(fmt => {
                    const btn = document.createElement('button');
                    btn.className = "w-full text-left px-4 py-3 hover:bg-slate-800 transition-colors border-b border-slate-800/60 last:border-0 text-sm text-slate-300 font-medium";
                    btn.textContent = fmt.label;
                    btn.onclick = (e) => { e.stopPropagation(); onSelectCallback(fmt.val); };
                    contentArea.appendChild(btn);
                });
            };
            categoriesData.forEach((cat, index) => {
                const btn = document.createElement('button');
                btn.className = `w-full text-left px-4 py-3 text-[10px] font-bold uppercase tracking-wider transition-colors border-l-2 ${index === 0 ? 'text-emerald-400 bg-slate-800/50 border-emerald-500' : 'text-slate-500 border-transparent hover:text-emerald-400 hover:bg-slate-800/30'}`;
                btn.textContent = cat.title;
                btn.onmouseenter = () => {
                    Array.from(sideBar.children).forEach(child => child.className = 'w-full text-left px-4 py-3 text-[10px] font-bold uppercase tracking-wider transition-colors border-l-2 text-slate-500 border-transparent hover:text-emerald-400 hover:bg-slate-800/30');
                    btn.className = 'w-full text-left px-4 py-3 text-[10px] font-bold uppercase tracking-wider transition-colors border-l-2 text-emerald-400 bg-slate-800/50 border-emerald-500';
                    renderRightSide(cat.formats);
                };
                btn.onclick = (e) => { e.stopPropagation(); btn.onmouseenter(); };
                sideBar.appendChild(btn);
            });
            if (categoriesData.length > 0) renderRightSide(categoriesData[0].formats);
            container.appendChild(sideBar); container.appendChild(contentArea);
        }

        function renderFromMenu() { 
            renderSplitMenu('from-selector-menu', inputCategories, selectFrom); 
        }

        function renderToMenu(inputType) {
            const options = (outputMaps[inputType] || []).filter(opt => opt.val !== selectedFrom);
            const grouped = {};
            options.forEach(opt => { if(!grouped[opt.category]) grouped[opt.category] = []; grouped[opt.category].push(opt); });
            const sortedCatNames = Object.keys(grouped).sort();
            const categoriesData = sortedCatNames.map(catName => ({ title: catName.toUpperCase(), formats: grouped[catName] }));
            renderSplitMenu('to-selector-menu', categoriesData, selectTo);
        }

        function selectFrom(val, skipUrlUpdate = false) {
            const data = inputCategories.flatMap(c => c.formats).find(f => f.val === val);
            if (!data) return;
            selectedFrom = val; 
            if(fromBadge) fromBadge.textContent = val.toUpperCase();
            if(fromLabel) fromLabel.textContent = data.label;
            if(fromMenu) fromMenu.classList.add('hidden');
            if (fileInputUniv) fileInputUniv.accept = data.accept;
            renderToMenu(data.type);
            const firstOpt = (outputMaps[data.type] || []).find(o => o.val !== val);
            if(firstOpt) selectTo(firstOpt.val, skipUrlUpdate);
            if (!skipUrlUpdate) updateHistory();
            if(window.lucide) lucide.createIcons();
        }

        function selectTo(val, skipUrlUpdate = false) {
            selectedTo = val; 
            if(toBadge) toBadge.textContent = val.toUpperCase();
            if(toLabel) toLabel.textContent = val.toUpperCase(); 
            if(toMenu) toMenu.classList.add('hidden'); 
            if (pendingFiles.length > 0) { 
                const files = [...pendingFiles]; pendingFiles = []; handleFiles(files); 
            }
            if (!skipUrlUpdate) updateHistory();
            if(window.lucide) lucide.createIcons();
        }

        // SEPARATE Metadata update from History update to prevent "Redirect" errors
        function updatePageMetaData(fromLabelText, toLabelText) {
            const toolName = `${fromLabelText} to ${toLabelText}`;
            
            // 1. Update Title
            document.title = `${toolName} | PrivaConvert`;
            const hero = document.getElementById('hero-main-heading');
            if (hero) hero.textContent = `${toolName} Converter`;
            
            // 2. Update Description
            const desc = document.getElementById('meta-desc');
            if (desc) desc.content = `Convert ${fromLabelText} to ${toLabelText} privately and locally. Free online ${fromLabelText} to ${toLabelText} converter.`;
            
            // 3. Update Canonical Tag (Crucial for SEO)
            const canonical = document.getElementById('canonical-url');
            if (canonical) {
                // Ensure we include the current query params in the canonical URL
                // This tells Google: "This specific URL is the authoritative source for this specific content"
                canonical.href = window.location.href;
            }
        }

        function updateHistory() {
            const flat = inputCategories.flatMap(c => c.formats);
            const fromData = flat.find(f => f.val === selectedFrom);
            if (!fromData || !selectedTo) return;
            
            // Update the UI/Meta first
            updatePageMetaData(fromData.label, selectedTo.toUpperCase());

            // Then update URL history
            try { 
                const url = new URL(window.location); 
                url.searchParams.set('from', selectedFrom); 
                url.searchParams.set('to', selectedTo); 
                window.history.pushState({}, '', url); 
            } catch (e) {}
        }

        function swapFormats() {
            if(!selectedFrom || !selectedTo) return;
            const flatInputs = inputCategories.flatMap(c => c.formats);
            const isValidInput = flatInputs.find(f => f.val === selectedTo);
            if (!isValidInput) { showMessage(`Cannot swap: '${selectedTo.toUpperCase()}' isn't a valid input.`, true); return; }
            const oldFrom = selectedFrom;
            selectFrom(selectedTo);
            const outputOpts = outputMaps[isValidInput.type] || [];
            if (outputOpts.find(o => o.val === oldFrom)) selectTo(oldFrom);
        }

        async function createWorker() {
            const workerCode = `
                self.window = self;
                self.document = { createElement: () => ({ style: {}, setAttribute: () => {}, appendChild: () => {} }), getElementsByTagName: () => [], head: { appendChild: () => {} } };
                importScripts('https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.11.6/dist/ffmpeg.min.js');
                self.onmessage = async function(e) {
                    const { type, data } = e.data;
                    if (type !== 'start') return;
                    const { fileData, fileName, outputFormat, id } = data;
                    let ffmpegInstance = null;
                    try {
                        ffmpegInstance = self.FFmpeg.createFFmpeg({ 
                            log: false, 
                            corePath: 'https://cdn.jsdelivr.net/npm/@ffmpeg/core-st@0.11.1/dist/ffmpeg-core.js', 
                            mainName: 'main' 
                        });
                        ffmpegInstance.setProgress(({ ratio }) => { self.postMessage({ type: 'progress', ratio }); });
                        await ffmpegInstance.load();
                        const ext = fileName.split('.').pop().toLowerCase();
                        const inputName = 'input.' + ext;
                        const outputName = 'output.' + outputFormat;
                        ffmpegInstance.FS('writeFile', inputName, new Uint8Array(fileData));
                        
                        let args = ['-i', inputName, '-strict', '-2'];
                        
                        // Handle Audio to Video conversion (muxing)
                        const audioExts = ['m4a', 'mp3', 'wav', 'flac', 'aac', 'ogg', 'aiff', 'wma'];
                        const videoExts = ['mp4', 'mkv', 'mov', 'webm', 'avi', 'wmv'];
                        
                        if (videoExts.includes(outputFormat)) {
                             args.push('-preset', 'superfast', '-crf', '25', '-tune', 'zerolatency');
                        }
                        
                        // Audio Metadata Strip to prevent crashes on specific formats
                        if (audioExts.includes(outputFormat)) {
                            args.push('-vn', '-map_metadata', '-1');
                        }

                        if (outputFormat === 'aiff') { args.push('-acodec', 'pcm_s16be', '-f', 'aiff'); }
                        else if (outputFormat === 'mp3') { args.push('-acodec', 'libmp3lame', '-q:a', '2'); }
                        else if (outputFormat === 'aac' || outputFormat === 'm4a') { args.push('-acodec', 'aac'); }
                        else if (outputFormat === 'wav') { args.push('-acodec', 'pcm_s16le'); }
                        
                        args.push('-y', outputName);
                        
                        try { await ffmpegInstance.run(...args); } catch(runErr) { if (!(runErr && (runErr.message === 'Program terminated' || runErr.status === 0))) throw runErr; }
                        const outData = ffmpegInstance.FS('readFile', outputName);
                        self.postMessage({ type: 'done', id, buffer: outData.buffer, format: outputFormat }, [outData.buffer]);
                    } catch (err) { self.postMessage({ type: 'error', id, msg: err.message }); }
                    finally { try { if(ffmpegInstance) ffmpegInstance.exit(); } catch(e){} }
                };
            `;
            return new Worker(URL.createObjectURL(new Blob([workerCode], { type: "text/javascript" })));
        }

        async function handleFiles(files) {
            const fileArray = Array.from(files);
            if (fileArray.length === 0) return;
            if (!selectedFrom || !selectedTo) {
                const file = fileArray[0];
                const ext = file.name.split('.').pop().toLowerCase();
                const flatInputs = inputCategories.flatMap(c => c.formats);
                const foundMatch = flatInputs.find(f => f.val === ext || (f.accept && f.accept.includes('.' + ext)));
                if (foundMatch) {
                    selectFrom(foundMatch.val);
                    pendingFiles = fileArray;
                    showMessage(`Detected ${foundMatch.label}. Select output format.`);
                    setTimeout(() => { if(toBtn) toBtn.click(); }, 100);
                    return;
                } else {
                    showMessage("Manual select required.", true); return;
                }
            }
            resultsAreaUniv.classList.remove('hidden');
            for (const file of fileArray) {
                const id = Math.random().toString(36).substr(2, 9);
                addLoadingItem(id, file.name, selectedTo);
                const task = async () => {
                    if (!isProcessing) return;
                    const statusEl = document.getElementById('status-' + id);
                    if(statusEl) statusEl.textContent = "Processing...";
                    const ffmpegFormats = ['mp4','mp3','aac','wav','mkv','webm','avi','mov','gif','ico','wmv','flac','aiff'];
                    if (file.type.startsWith('video/') || file.type.startsWith('audio/') || ffmpegFormats.includes(selectedTo)) await processMediaWorker(file, selectedTo, id);
                    else if (selectedTo === 'pdf' && file.type.startsWith('image/')) await new Promise(r => processImage(file, 'pdf', id, r));
                    else if (file.type.startsWith('image/')) await new Promise(r => processImage(file, selectedTo, id, r));
                    else if (file.type === 'application/pdf') {
                        if(['jpg','png','webp'].includes(selectedTo)) await processPdfExtract(file, selectedTo, id);
                        else if(['txt','md','html'].includes(selectedTo)) await processPdfText(file, selectedTo, id);
                    } else if (file.name.endsWith('.md') || file.name.endsWith('.txt')) await processText(file, selectedTo, id);
                    else markItemError(id, "Unsupported.");
                };
                conversionQueue.push(task);
            }
            processQueue();
        }

        async function processQueue() {
            if (isProcessing) return; isProcessing = true;
            while (conversionQueue.length > 0 && isProcessing) {
                const task = conversionQueue.shift();
                try { await task(); if(isProcessing) await new Promise(r => setTimeout(r, 800)); } catch (e) {}
            }
            isProcessing = false;
        }

        async function processMediaWorker(file, format, id) {
            return new Promise(async (resolve, reject) => {
                ffmpegLoader.classList.remove('hidden'); ffmpegStatus.textContent = "0%"; ffmpegProgress.style.width = "5%";
                cancelCurrentTask = () => { reject("Cancelled"); };
                const worker = await createWorker(); currentWorker = worker;
                worker.onmessage = function(e) {
                    if (e.data.type === 'progress') {
                        const pct = Math.round(e.data.ratio * 100); ffmpegStatus.textContent = `${pct}%`; ffmpegProgress.style.width = `${pct}%`;
                    } else if (e.data.type === 'done') {
                        finalizeItem(e.data.id, file.name, e.data.format, new Blob([e.data.buffer]));
                        worker.terminate(); ffmpegLoader.classList.add('hidden'); resolve();
                    } else if (e.data.type === 'error') {
                        markItemError(e.data.id, "Engine error."); worker.terminate(); ffmpegLoader.classList.add('hidden'); resolve(); 
                    }
                };
                const reader = new FileReader(); reader.onload = () => { if (worker) worker.postMessage({ type: 'start', data: { fileData: reader.result, fileName: file.name, outputFormat: format, id: id } }, [reader.result]); };
                reader.readAsArrayBuffer(file);
            });
        }

        function processImage(file, format, id, callback) {
            const reader = new FileReader(); reader.onload = (e) => {
                const img = new Image(); img.onload = () => {
                    if (format === 'pdf') {
                        const doc = new jspdf.jsPDF({ orientation: img.width > img.height ? 'l' : 'p', unit: 'px', format: [img.width, img.height] });
                        doc.addImage(img, 'JPEG', 0, 0, img.width, img.height); finalizeItem(id, file.name, 'pdf', doc.output('blob'));
                    } else {
                        const canvas = document.createElement('canvas'); canvas.width = img.width; canvas.height = img.height;
                        canvas.getContext('2d').drawImage(img, 0, 0);
                        canvas.toBlob(blob => finalizeItem(id, file.name, format, blob), `image/${format==='jpg'?'jpeg':format}`, 0.9);
                    }
                    if(callback) callback();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        async function processPdfExtract(file, format, id) {
            try {
                const pdf = await pdfjsLib.getDocument({ data: await file.arrayBuffer() }).promise;
                const zip = new JSZip();
                for (let i = 1; i <= pdf.numPages; i++) {
                    const page = await pdf.getPage(i); const vp = page.getViewport({ scale: 2.0 });
                    const canvas = document.createElement('canvas'); canvas.width = vp.width; canvas.height = vp.height;
                    await page.render({ canvasContext: canvas.getContext('2d'), viewport: vp }).promise;
                    zip.file(`page_${i}.${format}`, await new Promise(r => canvas.toBlob(r, `image/${format==='png'?'png':'jpeg'}`, 0.8)));
                }
                finalizeItem(id, file.name, 'zip', await zip.generateAsync({type:"blob"}), `${file.name}_extracted.zip`);
            } catch (e) { markItemError(id, "PDF Parse Error"); }
        }

        async function processPdfText(file, format, id) {
            try {
                const pdf = await pdfjsLib.getDocument({ data: await file.arrayBuffer() }).promise;
                let fullText = "";
                for (let i = 1; i <= pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    const textContent = await page.getTextContent();
                    fullText += textContent.items.map(item => item.str).join(' ') + '\n\n';
                }
                const mime = format === 'html' ? 'text/html' : format === 'md' ? 'text/markdown' : 'text/plain';
                let content = format === 'html' ? `<html><body><pre>${fullText}</pre></body></html>` : fullText;
                finalizeItem(id, file.name, format, new Blob([content], { type: mime }));
            } catch (e) { markItemError(id, "PDF Text Error"); }
        }

        async function processText(file, format, id) {
            const text = await file.text();
            if (format === 'html') finalizeItem(id, file.name, 'html', new Blob([marked.parse(text)], {type: 'text/html'}));
            else if (format === 'pdf') {
                const renderDiv = document.getElementById('hidden-render'); renderDiv.innerHTML = marked.parse(text);
                const canvas = await html2canvas(renderDiv, { scale: 2 });
                const pdf = new jspdf.jsPDF('p', 'mm', 'a4');
                pdf.addImage(canvas.toDataURL('image/png'), 'PNG', 0, 0, 210, (canvas.height * 210) / canvas.width);
                finalizeItem(id, file.name, 'pdf', pdf.output('blob')); renderDiv.innerHTML = '';
            }
        }

        function addLoadingItem(id, name, target) {
            const div = document.createElement('div'); div.id = id;
            div.className = "flex items-center justify-between bg-slate-800/50 p-4 rounded-lg border border-slate-700 animate-pulse";
            div.innerHTML = `<div class="flex items-center gap-3"><i data-lucide="loader-2" class="animate-spin text-emerald-500 h-5 w-5"></i><div><div class="text-sm font-medium text-white truncate max-w-[200px]">${name}</div><div id="status-${id}" class="text-xs text-slate-500">Queued...</div></div></div>`;
            if (fileListUniv) fileListUniv.appendChild(div); lucide.createIcons();
        }

        function finalizeItem(id, originalName, ext, blob, overrideName) {
            const div = document.getElementById(id); if (!div) return;
            const newName = overrideName || originalName.substring(0, originalName.lastIndexOf('.')) + '.' + ext;
            processedFiles.push({ name: newName, blob: blob });
            div.className = "flex items-center justify-between bg-slate-800 p-3 rounded-lg border border-emerald-500/30 transition-all scale-[1.02]";
            div.innerHTML = `<div class="flex items-center gap-3 overflow-hidden"><div class="bg-emerald-500/20 p-2 rounded-full flex-shrink-0"><i data-lucide="check" class="text-emerald-400 h-4 w-4"></i></div><div class="overflow-hidden"><div class="text-sm font-medium text-white truncate max-w-[150px] sm:max-w-[300px]">${newName}</div><div class="text-xs text-emerald-500">${formatBytes(blob.size)}</div></div></div><a href="${URL.createObjectURL(blob)}" download="${newName}" class="flex-shrink-0 flex items-center bg-slate-700 hover:bg-slate-600 text-white p-2 rounded-md transition-colors border border-slate-600"><i data-lucide="download" class="h-4 w-4"></i></a>`;
            lucide.createIcons(); if (downloadAllUniv) downloadAllUniv.classList.remove('hidden');
            setTimeout(() => { if(div) div.classList.remove('scale-[1.02]'); }, 300);
        }

        function markItemError(id, msg) {
            const div = document.getElementById(id); if (!div) return;
            div.className = "flex items-center justify-between bg-red-900/10 p-3 rounded-lg border border-red-500/30";
            div.innerHTML = `<div class="flex items-center gap-3"><i data-lucide="alert-triangle" class="text-red-500 h-5 w-5"></i><div><div class="text-sm font-medium text-white">Error</div><div class="text-xs text-red-400">${msg}</div></div></div>`;
            lucide.createIcons();
        }

        function cancelAll() {
            isProcessing = false; conversionQueue = []; pendingFiles = [];
            if(currentWorker) { currentWorker.terminate(); currentWorker = null; }
            if(cancelCurrentTask) { try { cancelCurrentTask(); } catch(e){} cancelCurrentTask = null; }
            if (ffmpegLoader) ffmpegLoader.classList.add('hidden');
            showMessage("Processes cancelled.", true);
        }

        function clearAll() { cancelAll(); if (fileListUniv) fileListUniv.innerHTML = ''; if (resultsAreaUniv) resultsAreaUniv.classList.add('hidden'); if (downloadAllUniv) downloadAllUniv.classList.add('hidden'); processedFiles = []; }
        function formatBytes(bytes) { if (!+bytes) return '0 B'; const k = 1024, sizes = ['B', 'KB', 'MB', 'GB'], i = Math.floor(Math.log(bytes) / Math.log(k)); return `${parseFloat((bytes / Math.pow(k, i)).toFixed(2))} ${sizes[i]}`; }

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            // Assign DOM elements to globals
            dropZoneUniv = document.getElementById('drop-zone-univ');
            fileInputUniv = document.getElementById('file-input-univ');
            resultsAreaUniv = document.getElementById('results-area-univ');
            fileListUniv = document.getElementById('file-list-univ');
            downloadAllUniv = document.getElementById('download-all-univ');
            ffmpegLoader = document.getElementById('ffmpeg-loader');
            ffmpegProgress = document.getElementById('ffmpeg-progress');
            ffmpegStatus = document.getElementById('ffmpeg-status');
            ffmpegLabel = document.getElementById('ffmpeg-label');
            fromBtn = document.getElementById('from-selector-btn');
            fromMenu = document.getElementById('from-selector-menu');
            fromBadge = document.getElementById('from-format-badge');
            fromLabel = document.getElementById('from-format-label');
            toBtn = document.getElementById('to-selector-btn');
            toMenu = document.getElementById('to-selector-menu');
            toBadge = document.getElementById('to-format-badge'); 
            toLabel = document.getElementById('to-format-label'); 
            swapBtn = document.getElementById('swap-btn');
            cancelBtn = document.getElementById('cancel-btn');

            renderFromMenu();
            
            // Set initial canonical for the homepage
            const canonical = document.getElementById('canonical-url');
            if (canonical && !canonical.href) canonical.href = window.location.href;

            // Handle URL params
            const params = new URLSearchParams(window.location.search);
            const f = params.get('from')?.toLowerCase(), t = params.get('to')?.toLowerCase();
            
            if (f) {
                const foundMatch = inputCategories.flatMap(c => c.formats).find(fmt => fmt.val === f);
                if (foundMatch) {
                    selectFrom(f, true); // true = skip history update
                    if (t) { 
                        const toMatch = outputMaps[foundMatch.type]?.find(o => o.val === t); 
                        if (toMatch) { 
                            selectTo(t, true); // true = skip history update
                            
                            // Manually update meta ONLY, do NOT touch history state on load
                            // This prevents Google from seeing a "redirect"
                            updatePageMetaData(foundMatch.label, t.toUpperCase());
                        } 
                    }
                }
            } else {
                if(fromBadge) fromBadge.textContent = "..."; 
                if(fromLabel) fromLabel.textContent = "Select";
                if(toBadge) toBadge.textContent = "..."; 
                if(toLabel) toLabel.textContent = "Select";
                const hero = document.getElementById('hero-main-heading');
                if(hero) hero.textContent = "Universal Local Converter";
                selectedFrom = null; selectedTo = null;
            }

            // SEO Link Delegation (Preserves SPA feel while using standard links)
            const seoContainer = document.getElementById('seo-links-container');
            if (seoContainer) {
                seoContainer.addEventListener('click', (e) => {
                    const link = e.target.closest('a');
                    if (link && link.classList.contains('seo-link')) {
                        // Prevent page reload to keep it fast for users
                        e.preventDefault();
                        const params = new URLSearchParams(link.getAttribute('href').replace('?', ''));
                        const f = params.get('from');
                        const t = params.get('to');
                        if (f && t) {
                            selectFrom(f);
                            selectTo(t);
                            window.scrollTo({ top: 0, behavior: 'smooth' });
                        }
                    }
                });
            }

            // Listeners
            if (fromBtn) fromBtn.addEventListener('click', (e) => { e.stopPropagation(); fromMenu.classList.toggle('hidden'); toMenu.classList.add('hidden'); });
            if (toBtn) toBtn.addEventListener('click', (e) => { e.stopPropagation(); toMenu.classList.toggle('hidden'); fromMenu.classList.add('hidden'); });
            if (swapBtn) swapBtn.addEventListener('click', swapFormats);
            if (cancelBtn) cancelBtn.addEventListener('click', cancelAll);
            document.addEventListener('click', () => { if(fromMenu) fromMenu.classList.add('hidden'); if(toMenu) toMenu.classList.add('hidden'); });
            
            if (dropZoneUniv) {
                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(e => dropZoneUniv.addEventListener(e, (ev) => { ev.preventDefault(); ev.stopPropagation(); }, false));
                ['dragenter', 'dragover'].forEach(e => dropZoneUniv.addEventListener(e, () => dropZoneUniv.classList.add('active'), false));
                ['dragleave', 'drop'].forEach(e => dropZoneUniv.addEventListener(e, () => dropZoneUniv.classList.remove('active'), false));
                dropZoneUniv.addEventListener('drop', (e) => { if(e.dataTransfer) handleFiles(e.dataTransfer.files); }, false);
            }
            if (fileInputUniv) fileInputUniv.addEventListener('change', (e) => { if(e.target) handleFiles(e.target.files); fileInputUniv.value = ''; }, false);
            if (downloadAllUniv) downloadAllUniv.addEventListener('click', async () => {
                const zip = new JSZip(); processedFiles.forEach(f => zip.file(f.name, f.blob));
                saveAs(await zip.generateAsync({type:"blob"}), "privaconvert_bundle.zip");
            });

            if(window.lucide) lucide.createIcons();
        });
    </script>
</body>
</html>
